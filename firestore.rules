rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUser(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isAccountType(type) {
      return isAuthenticated() && getUser(request.auth.uid).accountType == type;
    }

    // Users collection - users can read/write their own profile
    match /users/{userId} {
      // Users can read/write their own profile
      allow read, write: if isOwner(userId);

      // Allow reading basic public info
      allow read: if isAuthenticated();

      // Counselors can read their students' profiles
      allow read: if isAuthenticated() &&
        isAccountType('counselor') &&
        userId in getUser(request.auth.uid).studentIds;

      // Parents can read their children's profiles
      allow read: if isAuthenticated() &&
        isAccountType('parent') &&
        userId in getUser(request.auth.uid).studentIds;
    }

    // Applications collection
    match /applications/{applicationId} {
      // Students can read/write their own applications
      allow read: if request.auth != null && request.auth.uid == resource.data.studentId;

      // Institutions can read applications targeted to them
      allow read: if request.auth != null && request.auth.uid == resource.data.targetInstitutionId;

      // Counselors can read applications of their students (simplified)
      allow read: if request.auth != null && isAccountType('counselor');

      // Parents can read applications (simplified)
      allow read: if request.auth != null && isAccountType('parent');

      // Create validation
      allow create: if request.auth != null
        && request.auth.uid == request.resource.data.studentId
        && validateApplicationData(request.resource.data);

      // Update validation - students can update their own, institutions can update status
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.studentId ||
        request.auth.uid == resource.data.targetInstitutionId
      );
    }

    // Programs collection
    match /programs/{programId} {
      // Anyone authenticated can read programs (for browsing)
      // Note: Queries will be filtered by isActive on the client side
      allow read: if isAuthenticated();

      // Institutions can create/update/delete their own programs
      allow create: if isAuthenticated() &&
        isAccountType('institution') &&
        request.auth.uid == request.resource.data.institutionId &&
        validateProgramData(request.resource.data);

      allow update, delete: if isAuthenticated() &&
        isAccountType('institution') &&
        request.auth.uid == resource.data.institutionId;
    }

    // Messages collection
    match /messages/{messageId} {
      // Users can read messages sent to them or by them
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.recipientId);
      
      // Users can create messages (send)
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.senderId
        && validateMessageData(request.resource.data);
      
      // Users can update messages they received (mark as read)
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.recipientId
        && validateMessageUpdate(request.resource.data, resource.data);
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      
      // Users can update their own notifications (mark as read)
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.userId
        && validateNotificationUpdate(request.resource.data, resource.data);
      
      // System can create notifications (handled by Cloud Functions)
      allow create: if false; // Only Cloud Functions should create notifications
    }

    // Documents collection
    match /documents/{documentId} {
      // Users can read/write their own documents
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
      
      // Allow institutions to read documents in applications they're reviewing
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/applications/$(resource.data.applicationId)) &&
        get(/databases/$(database)/documents/applications/$(resource.data.applicationId)).data.targetInstitutionId == request.auth.uid;

      // Create validation
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && validateDocumentData(request.resource.data);
    }

    // Analytics collection (read-only for users)
    match /analytics/{analyticsId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
    }

    // Recommendation requests collection
    match /recommendation_requests/{requestId} {
      // Students can create and read their own requests
      allow read, write: if request.auth != null && request.auth.uid == resource.data.studentId;
      
      // Recommenders can read and update requests assigned to them
      allow read, update: if request.auth != null && request.auth.uid == resource.data.recommenderId;
      
      // Create validation
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.studentId
        && validateRecommendationRequest(request.resource.data);
    }

    // Global functions for validation
    function validateApplicationData(data) {
      return data.keys().hasAll(['studentId', 'targetInstitutionId', 'programId', 'status']) &&
        data.studentId is string &&
        data.targetInstitutionId is string &&
        data.programId is string &&
        data.status in ['draft', 'submitted', 'under_review', 'accepted', 'rejected'] &&
        data.createdAt == request.time &&
        data.updatedAt == request.time;
    }

    function validateApplicationUpdate(newData, oldData) {
      return newData.studentId == oldData.studentId &&
        newData.targetInstitutionId == oldData.targetInstitutionId &&
        newData.updatedAt == request.time;
    }

    function validateProgramData(data) {
      return data.keys().hasAll(['institutionId', 'name', 'isActive']) &&
        data.institutionId is string &&
        data.name is string &&
        data.isActive is bool &&
        data.createdAt == request.time &&
        data.updatedAt == request.time;
    }

    function validateMessageData(data) {
      return data.keys().hasAll(['senderId', 'recipientId', 'content', 'type', 'read']) &&
        data.senderId is string &&
        data.recipientId is string &&
        data.content is string &&
        data.type in ['text', 'file', 'system'] &&
        data.read == false &&
        data.createdAt == request.time;
    }

    function validateMessageUpdate(newData, oldData) {
      return newData.senderId == oldData.senderId &&
        newData.recipientId == oldData.recipientId &&
        newData.content == oldData.content &&
        (newData.read != oldData.read || newData.readAt != oldData.readAt);
    }

    function validateNotificationUpdate(newData, oldData) {
      return newData.userId == oldData.userId &&
        newData.title == oldData.title &&
        newData.message == oldData.message &&
        (newData.read != oldData.read || newData.readAt != oldData.readAt);
    }

    function validateDocumentData(data) {
      return data.keys().hasAll(['userId', 'fileName', 'storagePath', 'downloadURL']) &&
        data.userId is string &&
        data.fileName is string &&
        data.storagePath is string &&
        data.downloadURL is string &&
        data.createdAt == request.time &&
        data.updatedAt == request.time;
    }

    function validateRecommendationRequest(data) {
      return data.keys().hasAll(['studentId', 'recommenderId', 'status']) &&
        data.studentId is string &&
        data.recommenderId is string &&
        data.status in ['pending', 'accepted', 'completed', 'declined'] &&
        data.createdAt == request.time &&
        data.updatedAt == request.time;
    }
  }
}